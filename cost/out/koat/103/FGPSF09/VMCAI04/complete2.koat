WORST_CASE(?, O(1))

Initial complexity problem:
1:	T:
		(Comp: ?, Cost: 1)    pyRinit(Ar_0) -> Com_1(n_start(Ar_0))
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 0)    koat_start(Ar_0) -> Com_1(pyRinit(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

Repeatedly propagating knowledge in problem 1 produces the following problem:
2:	T:
		(Comp: 1, Cost: 1)    pyRinit(Ar_0) -> Com_1(n_start(Ar_0))
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 0)    koat_start(Ar_0) -> Com_1(pyRinit(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

Applied AI with 'oct' on problem 2 to obtain the following invariants:
  For symbol n_eval___1: -X_1 + 10 >= 0


This yielded the following problem:
3:	T:
		(Comp: 1, Cost: 0)    koat_start(Ar_0) -> Com_1(pyRinit(Ar_0)) [ 0 <= 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    pyRinit(Ar_0) -> Com_1(n_start(Ar_0))
	start location:	koat_start
	leaf cost:	0

By chaining the transition koat_start(Ar_0) -> Com_1(pyRinit(Ar_0)) [ 0 <= 0 ] with all transitions in problem 3, the following new transition is obtained:
	koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
We thus obtain the following problem:
4:	T:
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    pyRinit(Ar_0) -> Com_1(n_start(Ar_0))
	start location:	koat_start
	leaf cost:	0

Testing for reachability in the complexity graph removes the following transition from problem 4:
	pyRinit(Ar_0) -> Com_1(n_start(Ar_0))
We thus obtain the following problem:
5:	T:
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

By chaining the transition n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_0)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 ] with all transitions in problem 5, the following new transition is obtained:
	n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 ]
We thus obtain the following problem:
6:	T:
		(Comp: 1, Cost: 2)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

By chaining the transition n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 ] with all transitions in problem 6, the following new transition is obtained:
	n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 ]
We thus obtain the following problem:
7:	T:
		(Comp: 1, Cost: 3)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

By chaining the transition n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 ] with all transitions in problem 7, the following new transition is obtained:
	n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1'')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 /\ -Fresh_1'' + 10 >= 0 /\ 2*Fresh_1' + Fresh_1'' - 10 = 0 ]
We thus obtain the following problem:
8:	T:
		(Comp: 1, Cost: 4)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1'')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 /\ -Fresh_1'' + 10 >= 0 /\ 2*Fresh_1' + Fresh_1'' - 10 = 0 ]
		(Comp: ?, Cost: 1)    n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

Testing for reachability in the complexity graph removes the following transition from problem 8:
	n_eval___1(Ar_0) -> Com_1(n_eval___1(Fresh_1)) [ -Ar_0 + 10 >= 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Ar_0 + Fresh_1 - 10 = 0 ]
We thus obtain the following problem:
9:	T:
		(Comp: 1, Cost: 4)    n_eval___2(Ar_0) -> Com_1(n_eval___1(Fresh_1'')) [ -Fresh_0 + 10 >= 0 /\ 2*Ar_0 + Fresh_0 - 10 = 0 /\ -Fresh_1 + 10 >= 0 /\ 2*Fresh_0 + Fresh_1 - 10 = 0 /\ -Fresh_1' + 10 >= 0 /\ 2*Fresh_1 + Fresh_1' - 10 = 0 /\ -Fresh_1'' + 10 >= 0 /\ 2*Fresh_1' + Fresh_1'' - 10 = 0 ]
		(Comp: 1, Cost: 1)    n_start(Ar_0) -> Com_1(n_eval___2(Ar_0))
		(Comp: 1, Cost: 1)    koat_start(Ar_0) -> Com_1(n_start(Ar_0)) [ 0 <= 0 ]
	start location:	koat_start
	leaf cost:	0

Complexity upper bound 6

Time: 0.186 sec (SMT: 0.165 sec)

-- stats
realtime 0:00.19
usertime 0.16
systime 0.03

